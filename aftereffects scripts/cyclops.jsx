#include "lib/json2.js"var XMP_NAMESPACE = "http://www.weareinstrument.com/cyclops";var outputFile = null;var includeRawData = true;var includeKeyFrameData = false;var timeValueScale = 1000;var UI = {};var cyclopsData = {    "exportedProperties" : []};function saveMetaData() {    // load the XMP library as an ExtendScript ExternalObject     if (ExternalObject.AdobeXMPScript == undefined) {        ExternalObject.AdobeXMPScript = new        ExternalObject('lib:AdobeXMPScript');    }    var mdata = new XMPMeta(app.project.xmpPacket);        try {                // define new namespace        XMPMeta.registerNamespace(XMP_NAMESPACE, "cyc");                mdata.setProperty(XMP_NAMESPACE, "exportAsJson", UI["exportAsJson"].value ? 1 : 0);                if(UI["tweenName"].text != ""){            mdata.setProperty(XMP_NAMESPACE, "tweenName", UI["tweenName"].text);        }            if(outputFile){            mdata.setProperty(XMP_NAMESPACE, "outputFile", outputFile.absoluteURI);        }        var properties = getExportedPropertyList();        if(properties){            //$.writeln(JSON.stringify(properties));            mdata.setProperty(XMP_NAMESPACE, "properties", JSON.stringify(properties));        }    }    catch(e) {         alert(e);    }    app.project.xmpPacket = mdata.serialize();}function getExportedPropertyList(){    var exportList = [];    for(var i = 0; i < cyclopsData.exportedProperties.length; i++){        var p = cyclopsData.exportedProperties[i];        exportList.push({            "curveName" : p.tweenName,            "compName" : p.compName,            "layerName" : p.layerName,            "propertyGroupName" : p.propertyGroupName,            "propertyName" : p.propertyName        });    }    return exportList;}function readMetaData(){        if (ExternalObject.AdobeXMPScript == undefined) {        ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');    }    if(XMPMeta.getNamespacePrefix(XMP_NAMESPACE) != "") {        var mdata = new XMPMeta(app.project.xmpPacket);                if(mdata.doesPropertyExist(XMP_NAMESPACE, "tweenName")){            UI["tweenName"].text = mdata.getProperty(XMP_NAMESPACE, "tweenName");        }                if(mdata.doesPropertyExist(XMP_NAMESPACE, "exportAsJson")){            if(mdata.getProperty(XMP_NAMESPACE, "exportAsJson") == 1){                UI["exportAsJson"].value = true;                UI["exportAsVar"].value = false;            } else {                UI["exportAsJson"].value = false;                UI["exportAsVar"].value = true;            }        }          if(mdata.doesPropertyExist(XMP_NAMESPACE, "outputFile")){             outputFile = new File(mdata.getProperty(XMP_NAMESPACE, "outputFile"));             if(outputFile){                 UI["filePath"].text = outputFile.absoluteURI;             }        }        if(mdata.doesPropertyExist(XMP_NAMESPACE, "properties")){            var properties = JSON.parse( mdata.getProperty(XMP_NAMESPACE, "properties") );                        for(var i = 0; i < properties.length; i++){                var p = properties[i];                                var prop = getProperty(p.compName, p.layerName, p.propertyGroupName, p.propertyName);                if(prop){                    addProperty(p.curveName, prop);                }            }        }    }}// Find a specific property within the current project.// Holy nested-for-loops, Batman.function getProperty(compName, layerName, groupName, propertyName) {    // loop through all the project items    for(var i = 0; i < app.project.numItems; i++){        var comp = app.project.item(i+1);                // Find a composition with the target name        if((comp instanceof CompItem) && (comp.name == compName)){                            // iterate through all layers.            for(var n = 0; n < comp.numLayers; n++){                var layer = comp.layer(n+1)                                // Find the target layer                if((layer instanceof AVLayer) && (layer.name == layerName)){                    // loop through layer property groups                    for(var g = 0; g < layer.numProperties; g++){                        var group = layer.property(g+1);                        // find the target property group                        if((group instanceof PropertyGroup) && (group.name == groupName)){                            // Loop through individual properties                            for(var p = 0; p < group.numProperties; p++){                                // find the property we're looking for                                if(group.property(p+1).name == propertyName){                                    return group.property(p+1);                                }                            }                        }                    }                }            }        }    }    // didn't find it..    return null;}// Export keyframe data to a file.function exportData() {    if(outputFile == null){        setOutputFile();    }    if((UI["exportAsJson"] == false) && (UI["tweenName"].text == "")){        alert("You must specify a name for the tween data variable");        return;    }    if(outputFile){        var data = getExportData();        if(data){            outputFile.open("w");            try{                if(UI["exportAsJson"].value){                    outputFile.write(JSON.stringify(data));                } else {                    var tweenName = UI["tweenName"].text;                    outputFile.write( "var " + tweenName + " = " + JSON.stringify(data) + ";" );                }                outputFile.close();            }catch(e){                alert("Error Saving Data:\n" + e.message);            }        }    } else {        alert("no output file");    }}// Set the output file for export (this just sets the path, the file is not written here)function setOutputFile(){    outputFile = File.saveDialog("Choose an output file");        if(outputFile){        UI["filePath"].text = outputFile.absoluteURI;    }}// Get the entire map of properties/keyframes for all exported properties.function getExportData(){    var json = {};    var dataExists = false;        for(var i = 0; i < cyclopsData.exportedProperties.length; i++){        //$.writeln("Layer: " + cyclopsData.exportedProperties[i].layerName + ":" + cyclopsData.exportedProperties[i].propertyName);        var tween = cyclopsData.exportedProperties[i].tweenName;        var data = getKeyFrameInfoForProperty(cyclopsData.exportedProperties[i].property);        if(includeRawData){            data["frameData"] = getFrameData(cyclopsData.exportedProperties[i].property);                        // Convert fractional seconds to milliseconds            for(var n = 0; n < data["frameData"].length; n++){                data["frameData"][n].t = data["frameData"][n].t * timeValueScale;            }        }            if(data["frameData"] || data["keyframes"]){            var propertyName = cyclopsData.exportedProperties[i].propertyName.toLowerCase();                        if(!json[tween]){                var comp = getContainingCompForProperty(cyclopsData.exportedProperties[i].property);                                json[tween] = data;                json[tween]["_comp_bounds"] = [comp.width, comp.height];            }            dataExists = true;        }    }    if(dataExists){        return json;    }else{        return null;    }}function getContainingCompForProperty(prop){    var parent = prop.parentProperty;    while(!((parent instanceof AVLayer) || (parent instanceof TextLayer))){        parent = parent.parentProperty;    }    return parent.containingComp;}// Get a javascript object containing the data for all the keyframes of a given propertyfunction getKeyFrameInfoForProperty(prop){        var firstKeyTime = 100000000000000; // nobody would ever make a composition this long, right?!?  Right.    var lastKeyTime = -1;    var keyData = [];        if(prop.numKeys == 0){        return null;    }       for(var i = 0; i < prop.numKeys; i++){        var keyIndex = i + 1; // in the AE API, keyframe indices start at 1, not 0                if(prop.keyTime(keyIndex) > lastKeyTime){            lastKeyTime = prop.keyTime(keyIndex);        }                if(prop.keyTime(keyIndex) < firstKeyTime){            firstKeyTime = prop.keyTime(keyIndex);        }            var key = {            "time" : prop.keyTime(keyIndex),            "value" : prop.keyValue(keyIndex),            "in" : {                "type" : getEasingType(prop.keyInInterpolationType(keyIndex)),                "speed" : prop.keyInTemporalEase(keyIndex)[0].speed,                "influence" : prop.keyInTemporalEase(keyIndex)[0].influence,            },            "out" : {                "type" : getEasingType(prop.keyOutInterpolationType(keyIndex)),                "speed" : prop.keyOutTemporalEase(keyIndex)[0].speed,                "influence" : prop.keyOutTemporalEase(keyIndex)[0].influence,            }        };        if(prop.isSpatial){            key["hasTangents"] = true;            key["in"]["type"] = "bezier";            key["in"]["tangent"] = prop.keyInSpatialTangent(keyIndex);            key["out"]["type"] = "bezier";            key["out"]["tangent"] = prop.keyOutSpatialTangent(keyIndex);        } else {            key["hasTangents"] = false;        }           keyData.push(key);    }    var bounds = getMinMax(prop);        var propertyData = {        "duration" : (lastKeyTime - firstKeyTime) * timeValueScale,        "startTime" : firstKeyTime * timeValueScale,        "min" : bounds.min,        "max" : bounds.max,        "begin" : bounds.begin,        "end" : bounds.end    }    if(includeKeyFrameData){        // convert fractional seconds to milliseconds        for(var i = 0; i < keyData.length; i++){            keyData[i].time *= timeValueScale;        }        propertyData["keys"] = keyData;    }    return propertyData;}function getMinMax(prop){        var firstKeyTime = 100000000000000; // nobody would ever make a composition this long, right?!?  Right.    var lastKeyTime = -1;    if(prop.numKeys <= 1){        return null;    }       // find the first and last keyframe times.    for(var i = 0; i < prop.numKeys; i++){        var keyIndex = i + 1; // in the AE API, keyframe indices start at 1, not 0        if(prop.keyTime(keyIndex) > lastKeyTime){            lastKeyTime = prop.keyTime(keyIndex);        }                if(prop.keyTime(keyIndex) < firstKeyTime){            firstKeyTime = prop.keyTime(keyIndex);        }    }        var min = [];    var max = [];    var beginValues = prop.keyValue(1);    var endValues = prop.keyValue(prop.numKeys);    var tmp = prop.valueAtTime(1.0, null);    if(!tmp.length){       tmp = [tmp];    }    for(var i = 0; i < tmp.length; i++){        min.push(10000000000);        max.push(-100000000000);    }    var t = firstKeyTime;        while(t < (lastKeyTime + 1.0)){        var v = prop.valueAtTime(t, null);        if(!v.length){           v = [v];        }            for(var i = 0; i < v.length; i++){            if(min[i] > v[i]){                min[i] = v[i];            }            if(max[i] < v[i]){                max[i] = v[i];            }        }                t += 0.01; // arbitrary time step..    }    return {        "min" : min,        "max" : max,        "begin" : beginValues,        "end" : endValues    };}/** Translate numeric keyframe types to a string representation*/function getEasingType(typeId){    switch(typeId){        case KeyframeInterpolationType.LINEAR:            return "linear";        break;        case KeyframeInterpolationType.BEZIER:            return "bezier";        break;        case KeyframeInterpolationType.HOLD:            return "hold";        break;        default:            return "UNKNOWN";        break;    }}// Add properties selected in the composition to the list of exported propertiesfunction addSelectedProperty() {    if(!app.project || !app.project.activeItem){        return;    }    var layers = app.project.activeItem.selectedLayers;    // at least one property must be selected.    if(layers.length == 0){        alert("no properties selected.");        return;    }    for(var i = 0; i < layers.length; i++) {        //$.writeln("Layer: " + layers[i].name + " has " + layers[i].selectedProperties.length + " selected properties");        for(var p = 0; p < layers[i].selectedProperties.length; p++){            //$.writeln("Is group: " + (layers[i].selectedProperties[p] instanceof PropertyGroup));            if( !(layers[i].selectedProperties[p] instanceof Property) ){                alert("Please select an individual property, not a group of properties.");            } else if(!isPropertyExported(layers[i].selectedProperties[p])){                 var curveName = prompt("Curve name:", layers[i].name + "-" + layers[i].selectedProperties[p].name.toLowerCase());                 if(curveName != null){                    addProperty(curveName, layers[i].selectedProperties[p]);                 } else {                     break;                 }            } else {               // alert(layers[i].selectedProperties[p].name + " is already being tracked.");            }                }    }    UI["mainWindow"].layout.resize();}function addProperty(name, prop) {        var group = prop.parentProperty;    var layer = group.parentProperty;    var comp = layer.containingComp;        var newProp = {        "tweenName" : name,        "compName" : comp.name,        "layerName" : layer.name,        "propertyGroupName" : group.name,        "propertyName" : prop.name,        "property" : prop    };    cyclopsData.exportedProperties.push(newProp);        var item = UI["exportedProperties"].add( "item", name );   // item.subItems[0].text = prop.name;    item.subItems[0].text = comp.name + " / " + layer.name + " / " + group.name + " / " + prop.name;}// Removes a property from the listbox of exported properties.function removeSelectedProperty(){    if(UI["exportedProperties"].selection != null) {        cyclopsData.exportedProperties.splice(UI["exportedProperties"].selection.index, 1);        UI["exportedProperties"].remove( UI["exportedProperties"].selection );    }}// Checks to see if a given property is present in the list.function isPropertyExported(property){    var parentGroup = property.parentProperty;        if(parentGroup.name != "Transform"){        return false;    }        var parentLayer = parentGroup.parentProperty;    var parentComp = parentLayer.containingComp;        for(var i = 0; i < cyclopsData.exportedProperties.length; i++){        var exp = cyclopsData.exportedProperties[i];        if((exp.compName == parentComp.name) && (exp.layerName == parentLayer.name) && (exp.propertyName == property.name)){            return true;        }    }    return false;}function buildUI(contextObj){    var mainWindow = null;    if(contextObj instanceof Panel) {        mainWindow = contextObj;    } else {        mainWindow = new Window("palette", "Cyclops Data Export", undefined, {resizeable:true});        mainWindow.size = [640,300];    }        UI["mainWindow"] = mainWindow;            var inputGroup = mainWindow.add("group{orientation:'column',alignment:['fill', 'fill']}");        mainWindow.addEventListener("resize", function(e){        this.layout.resize();    });    mainWindow.addEventListener("close", function(e){        app.cancelTask(taskId);        stopServer();    });        var buttonGroup = inputGroup.add("group{orientation:'row',alignment:['left','top']}");    var addPropertyButton = buttonGroup.add ("button", undefined, "Add Property");     addPropertyButton.onClick = function(e) {        addSelectedProperty();    };    var removePropertyButton = buttonGroup.add("button", undefined, "Remove Property");    removePropertyButton.onClick = function(e) {        removeSelectedProperty();    };        UI["exportedProperties"] = inputGroup.add("ListBox", undefined, "exportedProperties",  {        alignment: ['fill','fill'],        numberOfColumns: 2,         showHeaders: true,         columnTitles: ['Curve Name', 'Source']        });    UI["exportedProperties"].alignment = ["fill", "fill"];    UI["exportedProperties"].onDoubleClick = function(e){            };        var tweenNameGroup = inputGroup.add("group{orientation:'row'}");        tweenNameGroup.alignment = ["fill","bottom"];    var bottomGroup = inputGroup.add("group{orientation:'row'}");        bottomGroup.alignment = ["fill","bottom"];            var tweenNameLabel = tweenNameGroup.add("statictext", undefined, "Export as:");    var radioJson = tweenNameGroup.add("radiobutton", undefined, "JSON data");    var radioNamedVar = tweenNameGroup.add("radiobutton", undefined, "Named object");        UI["exportAsJson"] = radioJson;    UI["exportAsVar"] = radioNamedVar;    var tweenName = tweenNameGroup.add("edittext");    tweenName.alignment = ["fill", "center"];    tweenName.text = "keyframeData";    UI["tweenName"] = tweenName;            var setPathButton = bottomGroup.add("button", undefined, "Browse");    setPathButton.alignment = ["left","center"];    setPathButton.onClick = function(e) {        setOutputFile();    };        var filePath = bottomGroup.add("statictext");    filePath.alignment = ["fill","center"];    filePath.text = "Output: (not specified)";    UI["filePath"] = filePath;        var exportDataButton = bottomGroup.add("button", undefined, "Export Properties");    exportDataButton.alignment = ["right","center"];    exportDataButton.onClick = function(e) {        exportData();        saveMetaData();    };        if (mainWindow instanceof Window)    {        mainWindow.onShow = function() {            readMetaData();        }        mainWindow.show();    }    else    {        mainWindow.layout.layout(true);        readMetaData();    }}buildUI(this);function getFrameData(prop) {    var comp = getContainingCompForProperty(prop);    var frameDuration = comp.frameDuration;    //$.writeln("Getting data for prop: " + prop.name);    //$.writeln("frame duration: " + frameDuration);    var firstKeyTime = 100000000000000; // nobody would ever make a composition this long, right?!?  Right.    var lastKeyTime = -1;    var keyData = [];        if(prop.numKeys == 0){        return null;    }       for(var i = 0; i < prop.numKeys; i++){        var keyIndex = i + 1; // in the AE API, keyframe indices start at 1, not 0                if(prop.keyTime(keyIndex) > lastKeyTime){            lastKeyTime = prop.keyTime(keyIndex);        }                if(prop.keyTime(keyIndex) < firstKeyTime){            firstKeyTime = prop.keyTime(keyIndex);        }    }        var t = firstKeyTime;    var data = [];        var tmp = prop.valueAtTime(1.0, null);    if(!tmp.length){       tmp = [tmp];    }     var min = [];    var max = [];        for(var i = 0; i < tmp.length; i++){        min.push(10000000000);        max.push(-100000000000);    }        while(t < (lastKeyTime + frameDuration )){        var v = prop.valueAtTime(t, null);        if(!v.length){           v = [v];        }            for(var i = 0; i < v.length; i++){            if(min[i] > v[i]){                min[i] = v[i];            }            if(max[i] < v[i]){                max[i] = v[i];            }        }                data.push( {"t" : t, "val" : v } );        t += frameDuration;    }    return data;}